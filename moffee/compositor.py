'):\n                    current_escaped = not current_escaped\n                if is_divider(line, type) and not current_escaped:\n                    strs.append('\n')\n                else:\n                    strs[-1] += line + '\n'\n            return [Chunk(paragraph=s) for s in strs]\n\n        vchunks = split_by_div(self.raw_md, '_')\n        for i in range(len(vchunks)):\n            hchunks = split_by_div(vchunks[i].paragraph, '*') \n            if len(hchunks) > 1: \n                vchunks[i] = Chunk(children=hchunks, type=Type.NODE)\n\n        if len(vchunks) == 1:\n            return vchunks[0]\n\n        return Chunk(children=vchunks, direction=Direction.VERTICAL, type=Type.NODE)\n\n    def _preprocess(self):\n        lines = self.raw_md.split('\n')\n        lines = [l for l in lines if not (1 <= get_header_level(l) <= 3)]\n        self.raw_md = '\n'.join(lines).strip()\n\n\ndef parse_frontmatter(document: str) -> Tuple[str, PageOption]:\n    document = document.strip()\n    front_matter = ''\n    content = document\n\n    if document.startswith('---\n'):\n        parts = document.split('---\n', 2)\n        if len(parts) >= 3:\n            front_matter = parts[1].strip()\n            content = parts[2].strip()\n\n    try:\n        yaml_data = yaml.safe_load(front_matter) if front_matter else {}\n    except yaml.YAMLError:\n        yaml_data = {}\n\n    option = PageOption()\n    for field in fields(option):\n        name = field.name\n        if name in yaml_data:\n            setattr(option, name, yaml_data.pop(name))\n    option.styles = yaml_data\n\n    return content, option\n\n\ndef parse_deco(line: str, base_option: Optional[PageOption] = None) -> PageOption:\n    def rm_quotes(s):\n        if (s.startswith('"') and s.endswith('"')) or (s.startswith("'") and s.endswith("'")):\n            return s[1:-1]\n        return s\n\n    deco_match = re.match(r'^\s*@\((.*?)\)\s*$', line)\n    if not deco_match:\n        raise ValueError(f'Input line should contain a deco, {line} received.')\n\n    deco_content = deco_match.group(1)\n    pairs = re.findall(r'([\"\w\-]+)\s*=\s*([^,]+)(?:,|$)', deco_content)\n    deco = {key.strip(): rm_quotes(value.strip()) for key, value in pairs}\n\n    if base_option is None:\n        base_option = PageOption()\n\n    updated_option = deepcopy(base_option)\n\n    for key, value in deco.items():\n        if hasattr(updated_option, key):\n            setattr(updated_option, key, parse_value(value))\n        else:\n            updated_option.styles[key] = parse_value(value)\n\n    return updated_option\n\n\ndef parse_value(value: str):\n    if value.lower() == 'true':\n        return True\n    elif value.lower() == 'false':\n        return False\n    elif value.isdigit():\n        return int(value)\n    elif value.replace('.', '', 1).isdigit():\n        return float(value)\n    return value\n\n\ndef composite(document: str) -> List[Page]:\n    pages = []\n    current_page_lines = []\n    current_escaped = False\n    current_h1 = current_h2 = current_h3 = None\n    prev_header_level = 0\n\n    document = rm_comments(document)\n    document, options = parse_frontmatter(document)\n\n    lines = document.split('\n')\n\n    def create_page():\n        nonlocal current_page_lines, current_h1, current_h2, current_h3, options\n        if all(l.strip() == '' for l in current_page_lines):\n            return\n\n        raw_md = ''\n        local_option = deepcopy(options)\n        for line in current_page_lines:\n            if contains_deco(line):\n                local_option = parse_deco(line, local_option)\n            else:\n                raw_md += '\n' + line\n\n        page = Page(raw_md=raw_md, option=local_option, h1=current_h1, h2=current_h2, h3=current_h3)\n\n        pages.append(page)\n        current_page_lines = []\n        current_h1 = current_h2 = current_h3 = None\n\n    for line in lines:\n        if line.strip().startswith('